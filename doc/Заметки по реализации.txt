Цель:
Создать средство, которое позволяет группировать отдельные файлы в некоторые группы по тегам или виртуальным папкам.
Файлы находятся на некотором "внешнем" хранилище и не дублируются в создаваемое "средство". Файлы могут присутствовать в нескольких папках, иметь несколько тегов.
Целевое применение:
организовать фильмотеку, чтобы можно было находить файлы по жанрам, актёрам или другим меткам.

Для реализации используем средство виртуальной файловой системы. Целевая ОС - Линукс.

Виртуальная файловая система будет представлять из себя модуль ядра, который создаёт некий тип файловой системы "tagvfs", эту файловую систему можно монтировать в общее пространство имён.

1 вариант реализации - tagvfs будет генерировать мягкие ссылки на внешние файлы и управлять ими (ссылками);
2 вариант реализации - tagvfs будет содержать виртуальные файлы, которые при запросе на чтение и запись будут использовать реальные файлы на "внешнем" носителе.

Оценочночное количество "внешних" файлов - десятки тысяч;
Общее количество тегов/папок - до 100, организация тегов/папок в древовидную структуру с уровнем вложенности до 5.





Базовые вещи про модуль ядра:
модуль может загружаться как отдельная сущность (собственно - модуль ядра). Также может собираться вместе с ядром.

Для сборки обычно используется утилита make. Она специально умеет распознавать, когда собирают модуль ядра по ключу M. И для сборки модулей ядра утилита make использует систему сборки kbuild.
Поэтому в Makefile есть как команды для make, так и для kbuild.

Часть, относящаяся к kbuild состоит из параметров вида:
obj-m := ...
something-y := ...
и т.д.

Для задания исходных файлов для сборки ядра есть 2 варианта:
1. Один исходный файл:
в этом случае этот файл именуется как результирующий модуль (например singlefile.c) и выставляется параметр:
obj-m := singlefile.o
В этом случае при сборке получим модуль singlefile.ko.
2. Несколько исходных файлов:
в этом случае добавляем параметр obj-m с желаемым именем модуля. Файл с исходным текстом с таким именем создавать НЕ НАДО, он фиктивный.
А сами исходники перечисляем в параметре "module name"-y. Например, для модуля multifile и файлов исходного кода source1.c, source2.c, source3.c:
obj-m := multifile.o
multifile-y := source1.o source2.o source3.o
Примечание:
- можно, конечно, создать и файл с кодом multifile.c и добавить его в параметр multifile-y для сборки. Но это не очень хорошо, т.к. будут выводиться сообщения вида:
make[3]: Циклическая зависимость /yyy/yyy.o <- /yyy/yyy.o пропущена.
- разделение названия модулей и исходных файлов предназначено (в том числе) чтобы собирать несколько модулей ядра. Это может использоваться для сборки модуля ядра, которому требуются экспортируемые сисмволы другого модуля. Подробнее в [1].


Обычное содержание Makefile файла:
?????

Точки входа:
Есть несколько способов определить точки входа в модуль. Например (рекомендуемый?):

static int tagvfs_init() { ... }

static void tagvfs_exit() { ... }


module_init(tagvfs_init)
module_exit(tagvfs_exit)


Также можно заявить явные функции
int init_module() { ... }
int cleanup_module() { ... }


Использование первого способа (module_init, module_exit) обладает рядом преимуществ, когда вы захотите собрать ваш код вместе с ядром. При этом указание на module показывает ядру на порядок загрузки кода: сначала загружаются адро, архитектура, файловые системы ... и где-то в конце уже обычные модули. Возможно, это неактуально, но не помешает.


Если при нициализации вернуть ошибку (-1), то модуль не загрузится и вывалится ошибка:
Возврат -1
insmod: ERROR: could not insert module tagvfs.ko: Operation not permitted

Вернули -3

insmod: ERROR: could not insert module tagvfs.ko: Module has wrong symbol version


Поэтому лучше использовать осмысленные коды ошибок (пользователь на -1 будет думать что у него sudo не достаточно мощное :) ).


???
MODULE_LICENSE("GPL");
       MODULE_AUTHOR("Valerie Henson <val@nmt.edu.>");
       MODULE_DESCRIPTION("\"Hello, world!\" minimal module");
       MODULE_VERSION("proc");

???


[1] http://www.larionov.mytomsk.ru/translate/%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5%D0%9C%D0%BE%D0%B4%D1%83%D0%BB%D0%B5%D0%B9%D0%AF%D0%B4%D1%80%D0%B0.pdf , поиск "Создание внешних модулей"


------------------------

Итак, файловая система:

Более подробно можно поискать в интернете по словам "Описание VFS Виртуальной Файловой Системы Linux" и "Linux Filesystems Documentation".

В целом, там многоходовка.
1. Описываем/регистрируем файловую систему. При этом даём ей какой-нибудь тип (tagvfs).

Далее нам нужно создать "СуперБлок" и всю обвязку. Также потребуются функции для монтирования файловой системы (и создания суперблока) и удаления суперблока.
Понятно, что можно создавать всё ручками (и обновлять при каждом движении ядра). И есть функции-помощники:
mount_nodev - генерирует данные для файловой системы без реального блочного устройства. Также есть другие: mount_bdev, mount_single. И для этих функций есть функции удаления суперблока. В нашем случае это generic_shutdown_super. Причём, если будет вызываться нееправильная функция, например kill_block_super (она тоже удаляет суперблок, но для блочных устройств), то всё закончится крэшем модуля.
Какие функции чему соответствуют и для чего - это очень непонятно из функций ядра и это та самая БОЛЬ.









[1] https://debuntu.ru/a/opisanie-vfs-virtualnoi-failovoi-sistemy-linux/? , поиск "Описание VFS Виртуальной Файловой Системы Linux"
[2] http://blog.foool.net/wp-content/uploads/linuxdocs/filesystems.pdf , поиск "Linux Filesystems Documentation"



-----------------
Объект inode

Представляет собой некоторое отображение объектов файловой системы в память. Также inode описывает функции, которыми можно оперировать.
Поля:
i_mode - тип файла по POSIX. Обязательно устанавливаем, иначе linux не сможет отличить директорию от всего остального
i_ino - уникальный номер inode
i_op
i_fop


i_mapping называется address_space. Это набор функций для управления кэшем файловых данных;
i_mapping->a_ops - это собственно операции.

i_atime, i_ctime, i_mtime - времена (время последнего доступа, создания и модификации)
для установки можно использовать функцию current_time, которой передаётся сам нод: смысл это подрезать время согласно самой файловой системе. Для этого в суперблоке есть поля s_time_gran (гранулярность в наносекундах) и s_time_min и s_time_max.






Хорошая ссылочка:
https://linux-kernel-labs.github.io/refs/heads/master/labs/filesystems_part2.html




------
Суперблок
- обязательно нужно задать указатель на структуру с операциями. Сами операции могут быть NULL ???


s_d_op - операции с dentry. и там есть поле d_init, эта функция вызывается после создания dentry.

s_fs_info - поле-указатель на некоторые приватные данные. Судя по исходникам, предполагается, что значение этого поля практически не меняется (ядро заботится о кэшировании).
Выделяем память и присваиваем в функции заполения суперблока, удаляем память в функции удаления суперблока (т.е. её придётся писать свою). Напомнимся, структура с 
функциями заполнения / удаления суперблока передаётся в функцию register_filesystem.






---------
dentry

Корневая директория  - с пустым именем


d_flags - маска битов как кэшировать записи о директории. По содержимому см. #define DCACHE_OP_HASH			0x00000001


для директории желательно?? задать 3 файловые операции:
open
release
iterate или shared_iterate

В качестве стартовой точки можно посмотреть на simple_dir_operations, которая использует dcache_dir_open, dcache_dir_close, dcache_readdir и ещё ряд других функций.

По составу поддиректорий:
Примеры в ядре сначала создают директорию "." (в позиции 0), потом директорию ".." (в позиции 1) и далее уже идёт требуемые поддиретории и др. Для создания первых двух директорий можно использовать функцию ядра dir_emit_dots.
Прим.: на практике получается, что директории можно не создавать. Если создать только "." (без "..") - всё будет работать (cd . , cd ..). 
Пример (монтируемая директория /tagfs/tag):

??:/tagfs$ cd tag
??:/tagfs/tag$ ls -a -l -i
итого 0
10000 drwxr-xr-x 2 root root 1000 апр 16 22:48 .
??:/tagfs/tag$ cd .
??:/tagfs/tag$ cd ..
??:/tagfs$ 




И если не создать обе - тоже всё будет работать. Возможно, у линукса есть цепочка парентов и он бегает по ней



В сейчашнем линуксе при работе с директориями работает следующая цепочка:
есть некий родительский inode (именно inode!). У этого inode есть файловые операции (поле i_fop). Для inode, отвечающего за директорию,
эти файловые операции содержат open, release, iterate / iterate_shared.
Для получения содержимого директории вызывается функция open, потом вызывается iterate до тех пор, пока dir_context->pos увеличивается:
в обработчике iterate вызываете функцию dir_emit куда заталкиваете новое/следующее имя, номер inode для этого имени и флаг (директория это или файл или ещё что).
В руководствах рекомендуется первыми двумя записями заталкивать . и .. (есть функция dir_emit_dots), но если этого не сделать эти записи как-бы виртуально есть (см. выше или где-то).
Далее, когда вся директория пройдена по именам, начинается создание/вычитывание inode для этих имён. Для этого используются inode операции для
родительского inode-а: поле i_op родительского inode. При этом если поле i_op будет NULL, то в такую директорию не получится перейти или получить список файлов. Однако, если в i_op записать адрес структуры, в которой будет только мембер lookup, который ничего не делает (возвращает NULL), то такая схема уже будет работать. (<В общем, не поймёшь, что можно задать как NULL, а что нельзя.>)




Поиск inode: на директории используется поле i_op с операциями по inode и там вызывается "метод" lookup. Ему передаётся родительский inode 
и предлагается новосозданный dentry, в котором заполнено имя того, что мы ищем. Соответственно нужно по имени из dentry найти inode
и прицепить его к dentry (через функцию d_add). И если всё хорошо - то вернуть NULL; если не всё хорошо, то вернуть код ошибки как указатель (например return ERR_PTR(код ошибки)). Если же у inode уже есть соответствующий dentry, к которому не нужно цепляться (какие-то странные вещи с корневым inode, у которого может быть только определённый dentry), то можно подпихнуть свой d_entry (используем d_move) и возвращаем указатель уже на свой dentry (подробнее см. struct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)).


Такой момент:
Линуксу может показаться, что в новопримонтированной файловой системе есть какие-то файлы (про которые ему не говорили). И
как только примонтировали файловую систему линукс может начать запрашивать странные файлы в корне. Например, в моём случае это .Trash и .Trash-1000    . Причём про эти файлы никто ничего не говорил. Более того, даже в примонтированную директорию ещё не зашли.





Общие замечания:

Учимся именовать всё через префиксы, пространств имён здесь нет.


Подстчёт ссылок:
для dentry есть функции dget и dput (увеличивает количество ссылок и уменьшает)
для inode функции igrab и iput (почему grab?)




Файл:



static inline struct inode *file_inode(const struct file *f)
{
	return f->f_inode;
}

static inline struct dentry *file_dentry(const struct file *file)
{
	return d_real(file->f_path.dentry, file_inode(file));
}


	if (S_ISDIR(mode))
			set_nlink(ret, 2);



